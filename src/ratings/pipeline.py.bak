from __future__ import annotations

import argparse
import json
from collections import defaultdict, deque
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, Tuple

import duckdb
import pandas as pd

from . import elo, xg

BASE_DIR = Path(__file__).resolve().parents[2]
DB_PATH = BASE_DIR / "database" / "betting.duckdb"
REPORTS_DIR = BASE_DIR / "reports"


@dataclass
class TeamState:
    elo: float
    xg_for: float = 0.0
    xg_against: float = 0.0
    matches_played: int = 0
    season: str = ""
    last_match: pd.Timestamp | None = None
    form: deque = field(default_factory=lambda: deque(maxlen=5))


class RatingsPipeline:
    def __init__(self, db_path: Path = DB_PATH) -> None:
        self.db_path = db_path
        self.con = duckdb.connect(str(db_path))
        self.params_by_div: Dict[str, elo.EloParameters] = {}
        self._load_competition_params()

    def _load_competition_params(self) -> None:
        df = self.con.execute("SELECT * FROM competitions").fetchdf()
        for row in df.itertuples(index=False):
            self.params_by_div[row.div] = elo.EloParameters(
                baseline=row.baseline_elo or 1500.0,
                k_factor=row.k_factor or 20.0,
                home_field=row.home_field or 50.0,
            )

    def _matches_with_stats(self) -> pd.DataFrame:
        matches = self.con.execute(
            "SELECT match_id, div, season, match_date, home_team, away_team, home_goals, away_goals, result FROM matches ORDER BY match_date"
        ).fetchdf()
        if matches.empty:
            return matches
        stats = self.con.execute("SELECT match_id, stat_name, stat_value FROM match_stats").fetchdf()
        if not stats.empty:
            pivot = stats.pivot(index="match_id", columns="stat_name", values="stat_value")
            matches = matches.join(pivot, on="match_id")
        return matches

    def update_team_ratings(self) -> pd.DataFrame:
        matches = self._matches_with_stats()
        if matches.empty:
            return pd.DataFrame()

        team_states: Dict[Tuple[str, str], TeamState] = {}
        results_by_div: Dict[str, set[str]] = defaultdict(set)

        for row in matches.itertuples(index=False):
            params = self.params_by_div.get(row.div, elo.EloParameters())
            home_key = (row.div, row.home_team)
            away_key = (row.div, row.away_team)

            home_state = team_states.get(home_key)
            if home_state is None:
                home_state = TeamState(elo=params.baseline, season=row.season)
                team_states[home_key] = home_state
            elif home_state.season != row.season:
                home_state.elo = elo.regress_towards_baseline(home_state.elo, params)
                home_state.xg_for *= 0.6
                home_state.xg_against *= 0.6
                home_state.matches_played = max(home_state.matches_played // 2, 0)
                home_state.season = row.season
                home_state.form.clear()

            away_state = team_states.get(away_key)
            if away_state is None:
                away_state = TeamState(elo=params.baseline, season=row.season)
                team_states[away_key] = away_state
            elif away_state.season != row.season:
                away_state.elo = elo.regress_towards_baseline(away_state.elo, params)
                away_state.xg_for *= 0.6
                away_state.xg_against *= 0.6
                away_state.matches_played = max(away_state.matches_played // 2, 0)
                away_state.season = row.season
                away_state.form.clear()

            if row.home_goals > row.away_goals:
                result_value = 1.0
                home_result = "W"
                away_result = "L"
            elif row.home_goals < row.away_goals:
                result_value = 0.0
                home_result = "L"
                away_result = "W"
            else:
                result_value = 0.5
                home_result = away_result = "D"

            home_shots = getattr(row, "home_shots", None)
            home_sot = getattr(row, "home_shots_on_target", None)
            away_shots = getattr(row, "away_shots", None)
            away_sot = getattr(row, "away_shots_on_target", None)

            home_xg = xg.estimate_xg(home_shots, home_sot, row.home_goals)
            away_xg = xg.estimate_xg(away_shots, away_sot, row.away_goals)

            home_state.elo, away_state.elo = elo.update_pair(
                home_state.elo,
                away_state.elo,
                result_value,
                params,
            )

            home_state.matches_played += 1
            away_state.matches_played += 1
            home_state.xg_for = xg.update_mean(home_state.xg_for, home_state.matches_played - 1, home_xg)
            home_state.xg_against = xg.update_mean(home_state.xg_against, home_state.matches_played - 1, away_xg)
            away_state.xg_for = xg.update_mean(away_state.xg_for, away_state.matches_played - 1, away_xg)
            away_state.xg_against = xg.update_mean(away_state.xg_against, away_state.matches_played - 1, home_xg)
            match_time = pd.to_datetime(row.match_date)
            home_state.last_match = match_time
            away_state.last_match = match_time
            home_state.form.appendleft(
                {
                    "date": match_time.strftime("%Y-%m-%d"),
                    "opponent": row.away_team,
                    "venue": "H",
                    "score": f"{row.home_goals}-{row.away_goals}",
                    "result": home_result,
                }
            )
            away_state.form.appendleft(
                {
                    "date": match_time.strftime("%Y-%m-%d"),
                    "opponent": row.home_team,
                    "venue": "A",
                    "score": f"{row.away_goals}-{row.home_goals}",
                    "result": away_result,
                }
            )

            results_by_div[row.div].add(row.season)

        records = []
        for (div_code, team_name), state in team_states.items():
            updated = state.last_match if state.last_match is not None else pd.Timestamp.utcnow()
            records.append(
                {
                    "div": div_code,
                    "team": team_name,
                    "season": state.season,
                    "elo": round(state.elo, 2),
                    "xg_for": round(state.xg_for, 2),
                    "xg_against": round(state.xg_against, 2),
                    "matches_played": int(state.matches_played),
                    "updated_at": updated,
                    "rolling_form": json.dumps(list(state.form)),
                }
            )

        ratings_df = pd.DataFrame.from_records(records)
        if ratings_df.empty:
            return ratings_df

        self.con.register("ratings_tmp", ratings_df)
        divs = ",".join(f"'{d}'" for d in ratings_df["div"].unique())
        self.con.execute(f"DELETE FROM team_ratings WHERE div IN ({divs})")
        self.con.execute(
            "INSERT INTO team_ratings SELECT div, team, season, elo, xg_for, xg_against, matches_played, updated_at, rolling_form FROM ratings_tmp"
        )
        self.con.unregister("ratings_tmp")

        REPORTS_DIR.mkdir(exist_ok=True)
        ratings_df.sort_values(["div", "elo"], ascending=[True, False]).to_csv(
            REPORTS_DIR / "team_ratings.csv", index=False
        )

        return ratings_df


    def generate_previews(self) -> pd.DataFrame:
        fixtures = self.con.execute(
            "SELECT fixt_id, div, match_date, home_team, away_team, source_file FROM fixtures_queue ORDER BY match_date"
        ).fetchdf()
        if fixtures.empty:
            return pd.DataFrame()

        ratings = self.con.execute(
            """
            SELECT div, team, season, elo, xg_for, xg_against, matches_played, updated_at
            FROM (
                SELECT *,
                       ROW_NUMBER() OVER (PARTITION BY div, team ORDER BY updated_at DESC) AS rn
                FROM team_ratings
            )
            WHERE rn = 1
            """
        ).fetchdf()
        rating_map = {
            (row.div, row.team): row for row in ratings.itertuples(index=False)
        }

        season_row = self.con.execute("SELECT season FROM matches ORDER BY match_date DESC LIMIT 1").fetchone()
        season_str = season_row[0] if season_row else None
        metrics_map: Dict[Tuple[str, str], pd.Series] = {}
        if season_str:
            metrics_df = self.con.execute(
                """
                WITH base AS (
                    SELECT m.div,
                           fs.team_name AS team,
                           m.match_date,
                           MAX(CASE WHEN fs.stat_type = 'Expected Goals' THEN fs.stat_value END) AS xg_for,
                           MAX(CASE WHEN fs.stat_type = 'Expected Goals Against' THEN fs.stat_value END) AS xg_against,
                           MAX(CASE WHEN fs.stat_type = 'Dangerous Attacks' THEN fs.stat_value END) AS da
                    FROM fixture_statistics fs
                    JOIN matches m ON fs.fixture_id = m.match_id
                    WHERE m.season = ?
                    GROUP BY 1,2,3
                ), ranked AS (
                    SELECT *,
                           ROW_NUMBER() OVER (PARTITION BY div, team ORDER BY match_date DESC) AS rn
                    FROM base
                )
                SELECT div, team,
                       AVG(xg_for) AS xg_for_avg,
                       AVG(xg_against) AS xg_against_avg,
                       AVG(da) AS da_avg
                FROM ranked
                WHERE rn <= 5
                GROUP BY 1,2
                """,
                [season_str],
            ).fetchdf()
            metrics_map = {
                (row.div, row.team): row for row in metrics_df.itertuples(index=False)
            }

        generated_at = pd.Timestamp.utcnow()
        records = []
        for row in fixtures.itertuples(index=False):
            params = self.params_by_div.get(row.div, elo.EloParameters())
            home_state = rating_map.get((row.div, row.home_team))
            away_state = rating_map.get((row.div, row.away_team))

            home_elo = float(home_state.elo) if home_state else params.baseline
            away_elo = float(away_state.elo) if away_state else params.baseline

            home_metrics = metrics_map.get((row.div, row.home_team))
            away_metrics = metrics_map.get((row.div, row.away_team))

            def _metric_value(metric_row, attr):
                if metric_row is None:
                    return None
                value = getattr(metric_row, attr, None)
                return float(value) if value is not None else None

            home_xg_form = _metric_value(home_metrics, 'xg_for_avg')
            away_xg_form = _metric_value(away_metrics, 'xg_for_avg')
            home_da_form = _metric_value(home_metrics, 'da_avg')
            away_da_form = _metric_value(away_metrics, 'da_avg')

            home_xg_val = home_xg_form if home_xg_form is not None else (float(home_state.xg_for) if home_state else None)
            away_xg_val = away_xg_form if away_xg_form is not None else (float(away_state.xg_for) if away_state else None)
            if home_xg_val is None:
                home_xg_val = 1.2
            if away_xg_val is None:
                away_xg_val = 1.2

            rating_diff = (home_elo + params.home_field) - away_elo
            if home_xg_form is not None and away_xg_form is not None:
                rating_diff += (home_xg_form - away_xg_form) * 60.0
            if home_da_form is not None and away_da_form is not None:
                rating_diff += (home_da_form - away_da_form) * 0.75

            p_home_raw = 1.0 / (1.0 + 10 ** (-rating_diff / 400))
            p_away_raw = 1.0 - p_home_raw
            p_draw = max(0.18, min(0.32, 0.26 - abs(rating_diff) / 1200))
            scale = 1.0 - p_draw
            p_home = p_home_raw * scale
            p_away = p_away_raw * scale

            total = p_home + p_draw + p_away
            if total > 0:
                p_home /= total
                p_draw /= total
                p_away /= total

            records.append(
                {
                    "fixt_id": row.fixt_id,
                    "div": row.div,
                    "match_date": pd.to_datetime(row.match_date),
                    "home_team": row.home_team,
                    "away_team": row.away_team,
                    "home_elo": round(home_elo, 2),
                    "away_elo": round(away_elo, 2),
                    "elo_edge": round(rating_diff, 2),
                    "home_xg": round(home_xg_val, 2),
                    "away_xg": round(away_xg_val, 2),
                    "home_da": round(home_da_form, 2) if home_da_form is not None else None,
                    "away_da": round(away_da_form, 2) if away_da_form is not None else None,
                    "prob_home": round(p_home, 3),
                    "prob_draw": round(p_draw, 3),
                    "prob_away": round(p_away, 3),
                    "generated_at": generated_at,
                }
            )

        preview_df = pd.DataFrame.from_records(records)
        self.con.register("previews_tmp", preview_df)
        self.con.execute("DELETE FROM fixture_previews")
        self.con.execute(
            "INSERT INTO fixture_previews SELECT fixt_id, div, match_date, home_team, away_team, home_elo, away_elo, elo_edge, home_xg, away_xg, home_da, away_da, prob_home, prob_draw, prob_away, generated_at FROM previews_tmp"
        )
        self.con.unregister("previews_tmp")

        REPORTS_DIR.mkdir(exist_ok=True)
        preview_df.sort_values("match_date").to_csv(REPORTS_DIR / "fixture_previews.csv", index=False)
        return preview_df


    def close(self) -> None:
            self.con.close()


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Ratings pipeline")
    sub = parser.add_subparsers(dest="command", required=True)

    upd = sub.add_parser("update", help="update team ratings from matches")
    upd.add_argument("--db", type=Path, default=DB_PATH)

    prev = sub.add_parser("preview", help="generate fixture previews")
    prev.add_argument("--db", type=Path, default=DB_PATH)

    return parser


def main() -> None:
    parser = _build_parser()
    args = parser.parse_args()
    pipeline = RatingsPipeline(db_path=args.db)
    try:
        if args.command == "update":
            df = pipeline.update_team_ratings()
            print(f"updated teams: {len(df)}")
        elif args.command == "preview":
            df = pipeline.generate_previews()
            print(f"previews: {len(df)}")
    finally:
        pipeline.close()


if __name__ == "__main__":
    main()
